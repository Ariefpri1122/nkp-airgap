From code-server (bastion VM) create a simple nginx container application:
--------------------------------------------------------------------------
mkdir workshop
cd workshop
mkdir arief
cd arief

vi Dockerfile #change ip address to your harbor registry ip address
from 10.38.106.41:5000/proxy_cache/nginx 
copy index.html /usr/share/nginx/html

vi index.html
<HTML>
<BODY>
<H1>
<CENTER>
LANDING PAGE ..... Arief Pribadi
</CENTER>
</H1>
</BODY>
</HTML>

export HARBOR_ADDRESS="$(kubectl -n kommander get kommandercluster host-cluster -o jsonpath='{.status.ingress.address}')"
echo $HARBOR_ADDRESS 

docker login -u nutanix -p nx2Tech974! https://$HARBOR_ADDRESS:5000/ #change ip address to your harbor registry ip address
docker build -f Dockerfile -t arief-nginx . # -->  If Failed, check endpoint healthy in harbor dashboard  
docker image ls 
docker tag arief-nginx:latest $HARBOR_ADDRESS:5000/library/arief-nginx:latest
docker image ls
docker push $HARBOR_ADDRESS:5000/library/arief-nginx
from harbor dashboard examine Projects - library - repositories

Create new Namespace and Create credential for harbor access:
cd /home/nutanix

kubectx --> make sure you use commander-cluster cluster context
export HARBOR_ADDRESS="$(kubectl -n kommander get kommandercluster host-cluster -o jsonpath='{.status.ingress.address}')"
echo $HARBOR_ADDRESS 

kubectx --> make sure you use managed-cluster cluster context
kubectl get ns
kubectl create ns arief-nginx #use your name 

kubens --> make sure you choose yourname-nginx namespace

REGISTRY_USERNAME="nutanix"
REGISTRY_PASSWORD="nx2Tech974!" #change password to your cluster password

kubectl create secret generic harbor-registry-credentials \
--from-literal username=$REGISTRY_USERNAME \
--from-literal password=$REGISTRY_PASSWORD \
--from-file=/etc/docker/certs.d/10.38.106.41:5000/ca.crt

*** DONT FORGET TO REPLACE YOUR HARBOR IP ADDRESS ABOVE BEFORE COPY PASTE ***


From Managed Cluster Kubernetes Dashboard:

Choose yourname namespace
Create new resource - Create from Form

Name              :  arief-nginx
container image   :  10.38.106.41:5000/library/arief-nginx # change to your harbor registry ip address
number of pods    :  1
service           :  external
port              :  80
target port       :  80
Show advanced option
image pull secret :  harbor-registry-credentials

While waiting you can check from harbor dashboard Projects - Library - arief-nginx - Artifacts --> Check it last pull time and date
Check deployment running
Check Services created - click external endpoint --> the web application shown

Create more complex application with persistent volue:
------------------------------------------------------
From managed-cluster kubernetes dashboard --> examine installed storage classes: nutanix-volume

Choose your project namespace from kubernetes dashboard

Apply below manifest using Create New Resources - Create from input in kubernetes dashboard

*** MAKE SURE YOU CHANGE THE IMAGE URL IN DEPLOYMENT MANIFEST INTO YOUR HARBOR PROXY_CACHE URL ***

mySQL Application:
------------------
apiVersion: v1
kind: Secret
metadata:
  name: mysql-pass
  type: Opaque
stringData:
  password: nutanix/4u
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  ports:
    - port: 3306
  selector:
    app: wordpress
    tier: mysql
  clusterIP: None
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
  labels:
    app: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-mysql
  labels:
    app: wordpress
spec:
  selector:
    matchLabels:
      app: wordpress
      tier: mysql
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: mysql
    spec:
      containers:
        - image: 10.38.106.41:5000/proxy_cache/mysql:8.0    # Change the IP into your harbor proxy_cache URL
          name: mysql
          env:
            - name: MYSQL_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-pass
                  key: password
            - name: MYSQL_DATABASE
              value: wordpress
            - name: MYSQL_USER
              value: wordpress
            - name: MYSQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mysql-pass
                  key: password
          ports:
            - containerPort: 3306
              name: mysql
          volumeMounts:
            - name: mysql-persistent-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mysql-persistent-storage
          persistentVolumeClaim:
            claimName: mysql-pv-claim
      imagePullSecrets:
        - name: harbor-registry-credentials

Check mySQL Deployment:
  - Click the Persistent Volume Claims option on the sidebar menu to see the persistent volume created for MySQL --> status bound
    * Copy the volume name (ex: pvc-85eef0b5-8f84-4231-8401-20eabe87d6c1)
  - Secret --> mysql-pass exist
  - Services --> wordpress-mysql exist
  - Deployment --> Status running
  - Using kubernetes dashboard - Pods - wordpress-mysql-xxx --> Click 3 button menu and click Exec
    * you are inside the mysql container --> ls /var/lib/mysql --> this is where the files stored in Nutanix CSI Storage
  - From Prism Central - Infrastructure - Storage - Volume Groups
    * search your volume name (ex: pvc-85eef0b5-8f84-4231-8401-20eabe87d6c1)
    * this is your new create volume group mapped to your new PVC

Wordpress Application:
----------------------
apiVersion: v1
kind: Service
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  ports:
    - port: 80
  selector:
    app: wordpress
    tier: frontend
  clusterIP: None
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pv-claim
  labels:
    app: wordpress
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress
  labels:
    app: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - image: 10.38.106.41:5000/proxy_cache/wordpress:apache   # Change the IP into your harbor proxy_cache URL
        name: wordpress
        env:
        - name: WORDPRESS_DB_HOST
          value: wordpress-mysql
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-pass
              key: password
        - name: WORDPRESS_DB_USER
          value: wordpress
        ports:
        - containerPort: 80
          name: wordpress
        volumeMounts:
        - name: wordpress-persistent-storage
          mountPath: /var/www/html
      volumes:
      - name: wordpress-persistent-storage
        persistentVolumeClaim:
          claimName: wp-pv-claim
      imagePullSecrets:
        - name: harbor-registry-credentials


Check WordPress Deployment:
  - Click the Persistent Volume Claims option on the sidebar menu to see the persistent volume created for WordPress --> status bound
  - Services --> wordpress-mysql exist
  - Deployment --> Status running
  - Using kubernetes dashboard - Pods - wordpress-mysql-xxx --> Click 3 button menu and click Exec
    * you are inside the mysql container --> ls /var/lib/mysql --> you will find wordress database directory there
    * ls /var/lib/mysql/wordpress/ --> to explore more the wordpress database files
    * mysql -u wordpress -p 
        - password: nutanix/4u
    * show databases;
    * use wordpress;
    * show tables;

Create Ingress to access wordpress:
-----------------------------------

*** Take a note that mysql and wordpress services above is "Headless" means clusterIP: None (Cant be expose by NodePort or LoadBalancer) ***

From kubernetes dashboard:
  - Click service - ingress classes from left pane menu --> there is a traefik ingress available in the cluster
  - Click service - ingresses --> you will see no ingresses in this namespace (yet)
  - Switch to All-Namespace to find trafik end point IP:
    * find "kommander-traefik" --> identify kommander-traefik services External End Point (Ex: 10.38.106.53)
  - Switch back to yourname-namespace (ex: Arief-nginx)
  - Click New Resources - Create from input and input below manifest

*** MAKE SURE YOU SWITCH YOU NAMESPACE INTO YOURNAME NAMESPACE (EX: ARIEF-NGINX) ***

Traefik Ingress Manifest
------------------------
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: wordpress
spec:
  ingressClassName: kommander-traefik
  rules:
    - host: wordpress.arief.com       # Change to yourname domain
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: wordpress
                port:
                  number: 80

Click service - ingresses --> make sure there is a wordpress ingress

--> From AUTOAD VM Add DNS A Host record of "wordpress" to kommander-traefik services External End Point (Ex: 10.38.106.53) in arief.com zone 
--> or add wordpress and its kommander-traefik services External End Point (Ex: 10.38.106.53) into your laptop host file

** Check wordpress application https://wordpress.arief.com


Deploy Application using GitOps Deployment
------------------------------------------
From NKP Manage-Cluster Dasboard - Projects - Create Project
Name              :  arief-project
Select Your Managed-Cluster
Create - Continue to project
Go to Continues Deployment (CD) Tab - Add GitOps Source
Name              :  online-boutique
Repository URL    :  https://github.com/nutanixdev/nkp-microservices-demo.git
Git Ref Type      :  Branch
Branch Name       :  main
Path              :  ./release/without-istio
Git Secret        :  none
Save

From Kubernetes Dashboard  -->  Check Deployment, make sure deployment success (Please be aware that creating new project will create new namespace based on your project name)

Troubleshooting redis card pod:
-------------------------------

This error is by desigend.
  - redis-cart error (this is happened because the image is in docker hub, while other deployment's image use gcp artifact with no auth and limit -- while docker hub has maximum limit):

From Code-Server (Bastion VM):
  - kubectx --> choose commander context
  
    export HARBOR_ADDRESS="$(kubectl -n kommander get kommandercluster host-cluster -o jsonpath='{.status.ingress.address}')"
    echo $HARBOR_ADDRESS

Create harbor-registry-credentials manifest in new project namespace:
---------------------------------------------------------------------

kubens --> make sure you choose your new project namespace

cat /etc/docker/certs.d/$HARBOR_ADDRESS:5000/ca.crt --> make sure the file exist

REGISTRY_USERNAME="nutanix"
REGISTRY_PASSWORD="nx2Tech974!" #change password to your cluster password

kubectl create secret generic harbor-registry-credentials \
--from-literal username=$REGISTRY_USERNAME \
--from-literal password=$REGISTRY_PASSWORD \
--from-file=/etc/docker/certs.d/$HARBOR_ADDRESS:5000/ca.crt

kubectl get secrets --> "harbor-registry-credentials" secret created

Modify RedisCart Deployment to fix the problem:
-----------------------------------------------
From NKP Dashboard - your workspace - Projects - your project - Continues Deployment (CD) :
  - Click 3 button menu from online-boutique GitOps Source
  - Click Suspend

From Kubernetes Dashboard:
  - Modify Redist-Card Reployment:
      * change the image location to --> image: 10.38.106.41:5000/proxy_cache/redis:alpine #Change the IP Address to your harbor IP

add below config (After dnspolicy): *** MAKE SURE imagePullSecrets IN THE SAME INDENT WITH dnspolicy ***
      imagePullSecrets:
        - name: harbor-registry-credentials

Click Update Button

* Make sure deployment Running
* For curousity open your harbor dashboard - Projects - proxy_cache ---> there is redis there in the repo with 1 pull

Go to Services - frontend-external --> click the external end points IP Address (make sure application shown)

From NKP Dashboard - your workspace - Projects - your project - Continues Deployment (CD) :
  - Click 3 button menu from online-boutique GitOps Source
  - Click Resume --> This is necessary if you already fixed the problem in the source code

  but for our case (its deliberetly to be broken), we will make the status SUSPENDED


OPTIONAL LAB (ONLY CAN BE DONE IF YOU HAVE NUTANIX FILES CONFIGURED IN YOUR CLUSTER)
====================================================================================

Create an NFS File Share
------------------------
- From your Prism Central (PC) dasbboard - Unified Storage - Files
- Click your File Server (ex: labFS) - Share & Exports - Click New Share or Export
  * Name                    : wordpress
  * Size                    : 10 GB
  * Primary Protocol Access : NFS
  * General Settings        : Default (no change)
  * Next
  * NFS Protocol Access     : Default (no change)
  * Next
  * Create
- Click your new wordpress share
  * Copy the Mount Path (ex: labFS.ntnxlab.local:/wordpress)

- From Code Proxy (bastion)
  * sudo mkdir /mnt/nfs_wordpress
  * sudo mount -t nfs labFS.ntnxlab.local:/wordpress /mnt/nfs_wordpress
  * cd /mnt/nfs_wordpress

Modify Wordpress Pods into 2 replicas with single PVC Claim
-----------------------------------------------------------
- From kubernetes dashboard - Your Name-nginx name space - Config and Storage 
  * From - Storage Classes --> You will see only 1 named nutanix-volume
  * From - Persistent Volume Claim --> You will see 2 PVC with ReadWriteOnce in nutanix-volume storage class
  * Create new resource - create from input:

apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nutanix-files
provisioner: csi.nutanix.com
parameters:
  nfsServerName: labFS
  nfsServer: labFS.ntnxlab.local
  nfsPath: wordpress
  storageType: NutanixFiles
  squashType: root-squash
reclaimPolicy: Delete
volumeBindingMode: Immediate
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: wp-pv-claim-nfs
  labels:
    app: wordpress
spec:
  storageClassName: nutanix-files
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi

- From kubernetes dashboard - Your Name-nginx name space
  * From Config and Storage - Storage Classes --> You will see nutanix-files
  * From Persistent Volume Claim --> wp-pv-claim-nfs with Read-Write-Many to nutanix files storage class
  * From Cluster - Persistent Volume --> the PV-xxxxxx-xxxxxx (with storage class nutanix-files) has BOND status

- From kubernetes dashboard - Your Name-nginx name space
  * Modify wordpress deployment:
    - Go to Volumes:
        - name: wordpress-persistent-storage
          persistentVolumeClaim:
            claimName: wp-pv-claim --> replace 'wp-pv-claim' to 'wp-pv-claim-nfs'
    - Go to spec:
        - replicas: 1 --> change it into replicas: 2
  * Go to Pods:
    - you will see 2 new created PODS 
      - Click 3 dot menu pod no #1 - click exec --> you are now in /var/www/html folder (this is the folder that using NFS CSI share), examine the files
      - Click 3 dot menu pod no #2 - click exec --> you will see same files (use ls)
  * Go to code-server (bastion)
    - ls /mnt/nfs_wordpress --> you will see pvc folder created by CSI driver
    - ls /mnt/nfs_wordpress/pvc-xxxxx --> you will see the same files as pod no #1 and no #2
